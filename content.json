[{"title":"Hexo笔记","date":"2019-07-31T16:35:55.000Z","path":"2019/08/01/Hexo笔记/","text":"记录下使用Hexo中的一些技巧和问题。 常用命令1234&gt; hexo new xxx // 生成xxx.md文章&gt; hexo g/generate [-d/—deploy] // 编译生成博客[并部署到服务器]&gt; hexo server // 启动本地服务器（可用于预览）&gt; hexo clean // 清理缓存 Deploy部署到Github失败的问题很久没更新微博，上次写了摄影笔记后满心欢喜地运行hexo g &amp;&amp; hexo s，本地预览效果完美，于是再次hexo clean &amp;&amp; hexo g -d，然后就去泡了杯咖啡，由于公寓里网速比较慢，摄影笔记这一篇博客图片又多（而且都是原图），上传很慢，但是等我玩了很久终于想起我还在上传博客时，得到了hexo的下列问题： RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 60 本来以为是没有挂vpn，上传太慢导致的time out，于是挂上vpn再次发布，结果并没有改变，想到会不会是图片太多太大导致git失败的，因此把图片全都上传，本地使用链接（方法可参见下面的使用微博做图床），花了半个小时左右去改，完成后再次hexo clean &amp;&amp; hexo g -d，还是同样的报错。。。 最后多方查证发现似乎是Git更新导致的一个问题（我果然很久没发布过博客了)，我这边的解决方法是修改_config.yaml的中的deploy配置地址，以前是https开头的Git项目地址，更换为git开头的即可： 123https://github.com/xxx/xxx.github.io.git |git@github.com:xxx/xxx.github.io.git 有传言更新Git版本也可以解决，但是我应该是使用了最新版本的Git。 使用微博作为图床如上所说，在解决Deploy失败时一度以为是图片太多太大，导致Hexo部署的问题，当时想到两个解决办法： 压缩图片再上传 找个图床 其实第二点一开始是没有想到的，但是在打开PS的那一刻突然想起自己有把图片发布到微博上，那么能不能直接使用微博上的图片链接呢？于是立刻行动，通过审查元素找到了一张图片的url，在本地立刻新建了一个markdown文件，通过![from weibo](https://xxxx)插入，在MacDown的预览界面是完美显示的，说明这个计划可行，于是花了半个小时把所有链接都爬了下来，然后手动修改之前Markdown里面的标签。完成后hexo g &amp;&amp; hexo s部署到本地，预览也是OK的，那没啥好说的了，hexo d发布！在发布成功后通过网址访问，发现一个令人猝不及防的问题：所有的微博图片都无法查看，链接失效，微博果然没有这么容易屈服。 经过多方查证，是从2019年4月底开始，微博开启了防盗链功能，导致直接引用会失效，目前来说解决方法很简单，在生成的网页代码中添加如下头信息即可： 1&lt;meta name=\"referrer\" content=\"no-referrer\" /&gt; 但是目前来说这个只是临时措施，什么时候会失效不可知，不过还是要感慨一下微博作为图床的好处： 免费！ 每张图片最多20M的大容量 无限图片 速度快，我的博客中有一张是没有上传的微博的，因此还是包含在本地文件中，明显在加载这张图片的速度远远慢于加载微博图片。 够稳定，这个没得说，只要不是鹿晗脱单、蔡徐坤发专辑之类的爆炸新闻，微博的服务器都是OK的。 不过这张处理方式也有缺点，我Hexo中使用的莱比力评论系统无法工作了，说不定还是要搞个七牛云或者考虑上传低分辨率图片。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"摄影笔记(一)","date":"2019-07-28T03:20:35.000Z","path":"2019/07/28/摄影笔记-一/","text":"前言这个博客已经荒废很久了，好在Github依然坚挺，不需要我担心服务器被收回云云。这么久没发布倒不是因为没有写东西，Hexo的Draft文件夹是一直在增加的，不过都是只言片语，没有整理成文，也就一直没有更新。 然而终究还是觉得需要养成写作记录的习惯，既然技术上坚持不下去，就试试写点其他的吧。 最近一直在业余时间（借相机）玩摄影，不过只是在起步阶段，无论是摄影本身技巧，还是后期处理都是小白阶段，刚好在这里记录一下自己的成长轨迹。否则拍的那些照片真是没地方用啊。 正题根据官方的介绍，萤火虫漫展是华南地区最受欢迎的漫展，虽然不知道是否属实，但就我多年逛展子的经验来看，这次的体验确实非同一般。不同于其他漫展最多两个展厅，萤火虫总共有两层楼四个展厅，规模之大也是罕见。并且其他的漫展更多的是一个主舞台+无数商家卖货，而萤火虫漫展只有第一层是商家，楼上的两个展厅都是各大厂商工作室的展厅，虽然也大多是卖周边，但档次还是高出不少的。诸如Sony PS、光荣等大厂也有参展，网易更是摆出了连环阵，阴阳师、明日方舟、第五人格、神都夜行录都设了单独的展厅，梦幻西游的周边也出现在了商场中，可以说是全家齐上阵了。 也有很多尚未发布上市的独立游戏提前预热，在现场举行了试玩活动进行宣传，而这些展台无一例外都有超美的小姊姊镇场，可以说是大饱眼福。下面是宝石研物语展台请来的Coser们。 除了这些有展厅的，也有工作室单独逛展的，在我刚进会场不久就遇到一家名为良一的实体娃娃制作工作室，一个大汉推着手推车，车里坐着等身高安琪拉（王者荣耀角色），第一眼看上去还以为是有父亲带着身体不便的女儿来逛漫展，接下来就想起了恐怖谷效应。。。除了真人，这一次也是看了很多的手办，大饱眼福，不得不说网易的手艺是真的好，手办做得惟妙惟肖，让我这个阴阳师拖坑多年的玩家差一点想要剁手了。 摄影师小白逛漫展的感谢漫展的一大好处是有很多很多很多的小哥哥小姊姊给你拍照，包括很多自行前来的素人Coser，一般是不会拒绝你的拍摄要求的，所以有很多机会练习。坏处则是人太多导致背景杂乱不堪，成片不见得能看,对于我这种新手来说，修图都不知道如何下手，比如下面这张： 只是将coser的面部调亮了，但是整个照片因为光圈不够大，背景看起来十分杂乱，终究缺了点感觉。 这一张也是，虽然尝试加了暗角去突出主体，但是背景虚化不够，整张照片也是，如果尝试用虚化工具可能会更好一点，但是我目前P图都是使用Lightroom，似乎没有这个功能。 不过经常也会有下面这几张背景光线都不错的时候。 另外也不要忘记去走廊阳台甚至漫展外面的场地逛逛，这些地方光线更好，因此也经常能遇到摆拍的coser和工作室，跟着蹭拍就好了。 完接下来就很期待8月份的BiliBili World啦！ 这里只是筛选了部分照片，所有修好的图我基本都发在微博上面来，欢迎交流学习，如果觉得还不错，请点赞关注鼓励一下@Levi_小明同学 PS:写完这篇我就意识到这可能是我的最后一篇摄影笔记了，用Markdown设置图片排版布局也太麻烦了，而且也并不好看，以后还是尽量筛选，放上部分照片就好 PPS:补充一下上面的，博客写完后发布不了，每次都提示ssl error，估计是图片又大又多，但是突然惊喜地发现可以用微博当图床😂","tags":[{"name":"摄影","slug":"摄影","permalink":"http://yoursite.com/tags/摄影/"}]},{"title":"CarouselLayoutManager源码解析","date":"2017-11-08T07:54:57.000Z","path":"2017/11/08/CarouselLayoutManager源码解析/","text":"CarouselLayoutManager简介CarouselLayoutManager实现的是旋转木马样式的RecyclerView布局，使用非常简单，直接新建出来再通过recyclerview.setLayoutManager()设置进去就能实现效果了，实际效果如下： 红线时demo中作者添加的效果，实际使用不会出现。但是由于项目需要实现的效果与标准CarouselLayoutManager实现的效果稍有出入，比如标准效果水平转动时所有item的中心都是在一条直线上，但需求时左右两边的item中心相对于中间高一些，其余诸如item间距以及缩放比例在CarouselLayoutManager中都没有开放出相对应的接口进行修改。因此我们需要对源码进行一点修改以定制效果，也可以借此机会了解了自定义LayouManager的相关知识。 源码下载及导入首先需要从github上clone下整个项目源码，如果对于自定义LayoutManager完全没有了解可以在等待clone完成的时候谷歌（或者百度）一下自定义LayoutManager的基础知识。clone完成后进入到项目文件夹可以看到实际上源码包含了carousel和sample两个项目，sample跑出来就是上面GIF图的效果，可以看看作者是怎么使用的或者用来查看修改后的效果，如果不感兴趣也可以直接打开carousel项目就行了。在导入整个项目时（我导入的时sample）会有个奇怪的问题时找不到local.properties文件，但这个文件实际上就在sample文件夹中，直接复制到项目根目录下再build就OK了。这是导入后的目录：如果是在项目中使用定制的CarouselLayoutManager只需要将com.azoft.carousellayoutmanager包下的代码全部复制进自己的项目就可以使用了。 源码分析源码中所有的英文注释都是Azoft大神自己的sample里面的代码很简单，不再细看，我们就研究一下Azoft大神时怎么实现的旋木效果就行，只要知道原理再去定制自己想要的效果就比较容易了。实现旋木效果的主要的代码都在CarouselLayoutManager.java中，我们就从这个文件开始分析。CarouselLayoutManager直接继承自RecyclerView.LayoutManager，必须重写的方法是generateDefaultLayoutParams()方法，但这个方法是为了设置item的默认LayoutParams，一般设置为RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);就好。而实现了旋木的主要工作都在onLayoutChildren()中，LayoutManager会在每次刷新时调用此函数，因此重写这个方法就可以实现任何布局以及滑动动画。1234567@Overridepublic void onLayoutChildren(@NonNull final RecyclerView.Recycler recycler, @NonNull final RecyclerView.State state) &#123; //前面做了很多工作是与初始准备及滑动的距离测量有关的，我在定制中没有需要修改到这部分，还没有深入研究，将来补上 ... //对item的绘制以及位置计算都放在了这里面 fillData(recycler, state, childMeasuringNeeded);&#125; fillData()函数内容： 12345678910111213141516171819202122private void fillData(@NonNull final RecyclerView.Recycler recycler, @NonNull final RecyclerView.State state, final boolean childMeasuringNeeded)&#123; final float currentScrollPosition = getCurrentScrollPosition(); //这个函数中通过各种计算确定了显示的item数量以及摆放顺序，详细分析在下。 generateLayoutOrder(currentScrollPosition, state); detachAndScrapAttachedViews(recycler); final int width = getWidthNoPadding(); final int height = getHeightNoPadding(); //这里针对不同的布局方向采用不同的位置计算方式，但最后都调用到了fillDataItem()中 if (VERTICAL == mOrientation) &#123; fillDataVertical(recycler, width, height, childMeasuringNeeded); &#125; else &#123; fillDataHorizontal(recycler, width, height, childMeasuringNeeded); &#125; //这里以及上面的detachAndScrapAttachedViews()都是在做内存的清理工作。 recycler.clear(); detectOnItemSelectionChanged(currentScrollPosition, state);&#125; generateLayoutOrder()函数比较重要了，Azoft在其中通过巧妙的方法实现了item之间层级的管理，代码分析如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void generateLayoutOrder(final float currentScrollPosition, @NonNull final RecyclerView.State state) &#123; mItemsCount = state.getItemCount(); final float absCurrentScrollPosition = makeScrollPositionInRange0ToCount(currentScrollPosition, mItemsCount); final int centerItem = Math.round(absCurrentScrollPosition); if (mCircleLayout &amp;&amp; 1 &lt; mItemsCount) &#123; /** *这里就比较坑了，mMaxVisible竟然时指的一边能看到的最大的数-1， *如果需要设置可见的最大数就需要在 *调用CarouselLayoutManager的setMaxVisibleItems()时自己先计算好。 *或者可以修改这个逻辑，将下句改为： * * final int layoutCount = Math.min(mLayoutHelper.mMaxVisibleItems, mItemsCount); * *我改为这样也没遇到什么问题，所以还不太明白为什么要 *2 + 3, *毕竟MaxVisibleItems这个名称很有迷惑性，一般都会认为就是整个Recyclerview可见的Item数量吧。 *如果你有其他想法也请不吝赐教。 **/ final int layoutCount = Math.min(mLayoutHelper.mMaxVisibleItems * 2 + 3, mItemsCount);// + 3 = 1 (center item) + 2 (addition bellow maxVisibleItems) //这里就是在mLayoutHelper中创建一个大小为layoutCount的数组保存item的摆放顺序 mLayoutHelper.initLayoutOrder(layoutCount); //计算出每一边的item数量 final int countLayoutHalf = layoutCount / 2; /** *下面两个for循环就是重点了，Azoft先向将左/上面的item依正序放入，再将右/下面的item以倒序放入，最后放入中间item *假如我们列表从左到右有5个item，他们在数组中的顺序时1 -&gt; 2 -&gt; 5 -&gt; 4 -&gt; 3 *这样做的好处是在不支持Z轴的低版本Android中，也能实现越靠近中间的item层级越高， *因为android中后放置的view在前一个view上上面 **/ // before center item for (int i = 1; i &lt;= countLayoutHalf; ++i) &#123; //当循环打开时摆放item后面的元素可能实际位置是在它前面，因此需要处理 final int position = Math.round(absCurrentScrollPosition - i + mItemsCount) % mItemsCount; mLayoutHelper.setLayoutOrder(countLayoutHalf - i, position, centerItem - absCurrentScrollPosition - i); &#125; // after center item for (int i = layoutCount - 1; i &gt;= countLayoutHalf + 1; --i) &#123; final int position = Math.round(absCurrentScrollPosition - i + layoutCount) % mItemsCount; mLayoutHelper.setLayoutOrder(i - 1, position, centerItem - absCurrentScrollPosition + layoutCount - i); &#125; mLayoutHelper.setLayoutOrder(layoutCount - 1, centerItem, centerItem - absCurrentScrollPosition); &#125; else &#123; ... &#125; generateLayoutOrder()中确定了即将显示出来的item以及他们的加入顺序，接下来就要进入到内容填充了，我们假设orentation为hrizontal继续分析： 1234567891011121314151617181920212223242526private void fillDataHorizontal(final RecyclerView.Recycler recycler, final int width, final int height, final boolean childMeasuringNeeded) &#123; /** *由于横向布局时中心高度不变，因此直接计算得出。 *Azoft是根据setScale实现缩放的，因此item的width和height并不会变，不用担心计算结果不同 *如果要实现中心高度不一致，不建议直接在这里修改，后面会提到另一个方法。 *如果一定要在这里修改需要注意根据不同Position计算出相应的值，毕竟全部提高50dp等于没有提高。 **/ final int top = (height - mDecoratedChildHeight) / 2; final int bottom = top + mDecoratedChildHeight; final int centerViewStart = (width - mDecoratedChildWidth) / 2; for (int i = 0, count = mLayoutHelper.mLayoutOrder.length; i &lt; count; ++i) &#123; final LayoutOrder layoutOrder = mLayoutHelper.mLayoutOrder[i]; /** *这个函数时根据item的位置计算出了它们相对于中心的偏移距离， *如果认为item之间距离不合适可以修改这个函数的计算逻辑 *内容很简单就不进去分析了，Azoft使用了Math.round()及Math.signum()计算结果，保证了中心的item不会有偏移，修改水平的偏移可以参考这个函数的思路。 **/ final int offset = getCardOffsetByPositionDiff(layoutOrder.mItemPositionDiff); final int start = centerViewStart + offset; final int end = start + mDecoratedChildWidth; //这个函数就是onLayoutChildren()的尽头了，里面完成了展示工作。 fillChildItem(start, top, end, bottom, layoutOrder, recycler, childMeasuringNeeded); &#125;&#125; 我们进入fillChidrenItem()中： 1234567891011121314151617181920212223242526private void fillChildItem(final int start, final int top, final int end, final int bottom, @NonNull final LayoutOrder layoutOrder, @NonNull final RecyclerView.Recycler recycler, final int i, final boolean childMeasuringNeeded) &#123; //创建出view并加入 final View view = bindChild(layoutOrder.mItemAdapterPosition, recyclerchildMeasuringNeeded); //这里设置了view的层级，但是由于我们时按照特殊顺序创建的itemView，这一句并不必要 ViewCompat.setElevation(view, i); ItemTransformation transformation = null; if (null != mViewPostLayout) &#123; /** *当ViewPostLayout不为空时获取动画效果，这个没有默认值，需要调用 * CarouselLayoutManager.setPostLayoutListener() *手动设置，但Azoft已经实现了一个动画效果，就在CarouselZoomPostLayoutListener.java中 *sample中也是使用了这个PostListener，如果我们需要定制CarouselLayoutManager，基本上参考这个就行了。 **/ transformation = mViewPostLayout.transformChild(view, layoutOrder.mItemPositionDiff, mOrientation); &#125; //下面就没有什么好说的了，将前面计算出的数据设置给子item，完成了整个绘制过程。 if (null == transformation) &#123; view.layout(start, top, end, bottom); &#125; else &#123; view.layout(Math.round(start + transformation.mTranslationX), Math.round(top + transformation.mTranslationY), Math.round(end + transformation.mTranslationX), Math.round(bottom + transformation.mTranslationY)); ViewCompat.setScaleX(view, transformation.mScaleX); ViewCompat.setScaleY(view, transformation.mScaleY); &#125;&#125; 因此我们最后看看CarouselZoomPostLayoutListener.java： 1234567891011121314151617181920212223242526public class CarouselZoomPostLayoutListener implements CarouselLayoutManager.PostLayoutListener &#123; @Override public ItemTransformation transformChild(@NonNull final View child, final float itemPositionToCenterDiff, final int orientation) &#123; /** *这个计算缩放的方法把我看懵了，最后用软件画出来就是一个相对Y轴对称的山包样式，要修改缩放梯度也很简单， *只需要将itemPositionToCenterDiff乘以或者除以一个比例就行了。 **/ final float scale = (float) (2 * (2 * -StrictMath.atan(Math.abs(itemPositionToCenterDiff) + 1.0) / Math.PI + 1)); // because scaling will make view smaller in its center, then we should move this item to the top or bottom to make it visible //其实就是在缩放后修正view的位置，让它再次居中，因为缩放并非以view的中心为锚点。所以如果需要将两侧的view上移或者下移修改这里就好了 final float translateY; final float translateX; if (CarouselLayoutManager.VERTICAL == orientation) &#123; final float translateYGeneral = child.getMeasuredHeight() * (1 - scale) / 2f; translateY = Math.signum(itemPositionToCenterDiff) * translateYGeneral; translateX = 0; &#125; else &#123; final float translateXGeneral = child.getMeasuredWidth() * (1 - scale) / 2f; translateX = Math.signum(itemPositionToCenterDiff) * translateXGeneral; translateY = 0; &#125; return new ItemTransformation(scale, scale, translateX, translateY); &#125;&#125; 至此我们就大概梳理完了CarouselLayoutManager的流程，但是通过目前这些我们已经可以去订制CarouselLayoutManager了。 坑由于我们是通过另类的顺序加入的view，因此直接调用recyclerview.getChildAt()获取到的view可能并非你希望得到的想要的（当然就算时普通recyclerview也可能不是），因此使用Azoft实现的一个监听器，可以直接使用。如果你设定了循环模式，那么还有一个更简单的解决的方法。我们的放入顺序决定了当前被选中的（中间的View）一定是第recyclerview.getChildCount()-1个，也就是最后一个，因此可以直接通过recyclerview.getChildAt(recyclerview.getChildCount()-1)就可以获取到被选中的view。 以上在阅读源码的过程中一开始真的无从下手，光是CarouselLayoutManager.java就有800多行代码，那么多方法和内部类，一行一行地看很快就头晕眼花了，但是在了解了LayoutManager原理以及绘制过程后，根据流程一步一步走，思路就慢慢清晰了起来。第一次写源码分析，在编写过程中发现自己还是有很多没弄懂的地方，整个文章写完又学习到不少东西，但是可能写得很乱，如有任何问题或者建议请直接留言、邮件、QQ垂询。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/源码分析/"}]},{"title":"Android TV开发笔记一","date":"2017-10-18T15:38:14.000Z","path":"2017/10/18/Android-TV开发笔记一/","text":"今天在开发TV Launcher时使用RecyclerView实现界面时遇到了遥控器无法对焦的问题，但连接上鼠标后没有问题，因此需要配置RecyclerView的Item获取焦点。一般的做法是将RecyclerView与ViewHolder的itemView均设为可点击，然后对焦点变更时间进行监听，当RecyclerView获取到焦点时分发给item： 1234567891011121314151617181920212223242526272829public MyAdapter extends RecyclerView.Adapter&lt;MyViewHolder&gt; &#123; ... class MyViewHolder extends RecyclerView.ViewHolder &#123; MyViewHolder(View itemView)&#123; super(itemView); itemView.setFocusable(true); &#125; &#125;&#125;.../**这里也可以在xml文件中设置focusable = \"true\"*/RecyclerView rv = (RecyclerView) findViewById(R.id.recyclerView);rv.setFocusable(true);//RecyclerView监听焦点改变事件rv.setOnFocusChangeListener(new View.OnFocusChangeListener() &#123; @Override public void onFocusChange(View v, boolean hasFocus) &#123; if (hasFocus)&#123; //先判断是否有子控件，防止空指针。 if (rv.getChildCount() &gt; 0)&#123; //我默认使第一个item获取焦点，可以任意修改 irv.getChildAt(0).requestFocus(); &#125; &#125; &#125; &#125;); 以上代码就能使RecyclerView得到焦点后分配给子控件，解决电视遥控器无法使RecyclerView滚动的问题。 但是。。。这是以前的解决方法，今天在使用一个复杂的LayoutManager时发现子控件获取到了焦点，但不知是焦点闪烁还是什么原因导致不停按按钮才能滑动到下一个item，这个目前还没有发现原因，但是由于这个问题只在遥控器控制时出现，所以想要解决还是很简单的。 解决方法便是，禁止itemView获取焦点，然后由RecyclerView监听按键事件，当获取到遥控器按下左或右时调用smoothScrollToPosition(int position)的方法完成切换，代码如下： 123456789101112131415161718rv.setOnKeyListener(new View.OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; iif (event.getAction() == KeyEvent.ACTION_UP)&#123; switch (keyCode)&#123; case KEY_LEFT: itemList.smoothScrollToPosition(lastPos); return true; case KET_RIGHT: itemList.smoothScrollToPosition(nextPos); return true; default: return false; &#125; &#125; return false; &#125; &#125;); 至于为什么会出现类似焦点闪烁的问题，有待研究，希望知道的大神们能点拨一下😂。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"TV 开发","slug":"TV-开发","permalink":"http://yoursite.com/tags/TV-开发/"}]},{"title":"Kotlin学习笔记二","date":"2017-05-21T02:43:29.000Z","path":"2017/05/21/Kotlin学习笔记二/","text":"属性和字段属性声明官方文档有这样一段话 其初始器（initializer）、getter 和 setter 都是可选的。属性类型如果可以从初始器 （或者从其 getter 返回值，如下文所示）中推断出来，也可以省略。例如: 12345&gt;var allByDefault: Int? // 错误：需要显式初始化器，隐含默认 getter 和 setter&gt;...&gt;val simple: Int? // 类型 Int、默认 getter、必须在构造函数中初始化&gt;...&gt; 附带的实例代码让我以为 val simple: Int? 这种写法是正确的，val与var在声明中由于Getter与Setter的不同导致声明方式存在差异。但是实际上不是这样的。 在类的声明中以上两种写法均无法通过编译。 12345678class Person constructor()&#123; var name: String? val age : Int? init&#123; name = \"名字\" age = 7 &#125;&#125; 如果不为属性直接指定值var name = &quot;名字&quot;那么就要在init中进行初始化。 我们也可以为属性添加lateinit修饰符使空属性避免初始化 1234class Person constructor()&#123; lateinit var name : String &#125; 上面代码可以通过编译，但是这里的p不能是原生类型如Int，并且只能是var属性。 幕后字段幕后字段是中文文档的翻译，原文为field，但是在我的印象中这个单词应该一般认为是域，在案例代码的使用场景是setter函数中的赋值。 12345678910111213class Person constructor()&#123; var name = \"老李\" set(n)&#123; name = n &#125; &#125;fun main(args: Array&lt;String&gt;) &#123; val p = Person(); println(p.name) p.name = \"老王\" println(p.name)&#125; 上述代码是无法通过编译的，虽然我们指定了name为可变的var类型，但是set函数中无法直接引用name，因此我们将函数修改为： 1234var name = \"老李\" set(n)&#123; field = n &#125; 就可以运行了，当然如果不需要在set函数中实现特殊功能，我们可以不显示声明这个函数 123456789class Person constructor()&#123; var name = \"老李\"&#125;fun main(args: Array&lt;String&gt;) &#123; val p = Person(); println(p.name) p.name = \"老王\" println(p.name)&#125; 上述代码也是完全没有问题的。 这里的不能引用仅仅是在属性的SETTER与GETTER函数中，类声明的函数是可以直接调用的： 123456class Person()&#123; var name = \"老李\" fun print()&#123; println(name) &#125;&#125; 我理解的field就是属性在Getter和Setter中对自身的引用，类似于Java中的this，我们在其他属性的Setter和Stter中依然可以直接引用属性: 123456789101112class Person constructor()&#123; private var age = 12 var getAge : Int get() = age set(a)&#123; age = a &#125; var name = \"老李\" set(name)&#123; field = name &#125;&#125; 可见性修饰符Kotlin中的可见性修饰符与Java中稍有差异。Kotlin中不指定任何修饰符则默认为public，而internal为在同意模块中可见，与Java中的缺省修饰符类似。而protected虽然仍然存在却不推荐使用在顶层声明。 需要说明的一点是private的定义是在同一个文件下才可被访问，然而实际上仍然是在类中才可被访问，如果我们将下列代码写在同一.kt文件中仍然不能运行： 1234567class Person constructor()&#123; private var name = \"老李\"&#125;fun main(args: Array&lt;String&gt;) &#123; val p = Person(); print(p.name)&#125; 这里也许是指的编译后的文件。 扩展属性关于扩展属性需要说明的一点是扩展属性没有幕后字段，所以扩展属性不能有初始化器，在Setter和Getter中也不能通过field来修改值，因此使用场景需要斟酌。 密封类密封类的含义看中文文档和代码完全没懂是什么意思。后来又找了些资料，大概理解了密封类是作为类似枚举的存在，密封类的每个子类都是枚举常量，可以通过is 父类.子类进行类型判断。 与普通枚举不同的是密封类的子类可以有多个实例，而枚举常量只有一个实例存在。 使用密封类的好处就是已知了子类的所有可能类型，便于进行判断处理。 伴生对象伴生对象可通过类名.方法进行调用，虽然看起来很像Java中类的静态成员，但实际上伴生对象仍然是类的实例的的实例成员。","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/tags/Kotlin/"}]},{"title":"Kotlin学习笔记一","date":"2017-05-18T15:23:12.000Z","path":"2017/05/18/Kotlin学习笔记一/","text":"今天的Google开发者大会除了宣布Google的战略重点从移动端转移到AI领域外，另一向重点就是钦定了Kotlin为以后Android开发的第一语言。 Kotlin的大名我是早有耳闻，但是一直懒没有去学，而且当时Kotlin目前也仍处于发展中。如今有了Google的鼎力支持，再加上我最近颓废至极也该找点事做，于是去搜集了Kotlin的开发资料开始学习。 我使用的学习资料是不知谁翻译的Kotlin官方文档中文版。第一步当然是从语法开始。但是如果你也是为了Android应用开发（目前Kotlin的主要应用领域），那么也许你也熟悉了Java语言，学习Kotlin就十分轻松了，我只记录下自己认为的重点。- Kotlin基本语法 不需要;作为句末 var与val的区别：Kotlin中所有的变量首先都是声明为val或者var，再赋值，若不赋值再指定类型。val为只读类型，var为可读写 1234567val a = 1 // 直接赋值Kotlin会识别数据类型var b : Int //Int首字母大写；指定b的数据类型为inta = 2 //运行出错，a值不可变b = 1b = 2 //修改b的值正常运行 when的特殊使用 1234567val a = 1when(a)&#123; 1 -&gt; println(\"a == 1\") is Int -&gt; println(\"a is int\") else -&gt; println(\"unkown\") &#125;//输出为 “a == 1” 上面这段代码可以看出when替代了java中switch的作用，但是需要注意的一点是这里没有break，虽然a既等于1又是int但是输出判断出第一个条件正确后立即跳出，不会再继续向下判断。 几种区间比较:Kotlin中有几种表示范围的方法 123456for(i in 1..10)&#123;...&#125; //这种情况下循环中i会取1到10for(i in 10..1)&#123;...&#125; //直接结束循环for(i in 1..10 step 4)&#123;...&#125; //i = 1,5,9for(i in 10 downTo 1)&#123;...&#125; //i取10到1for(i in 10 downTo 1 step 4) //i = 10,6,2for(i in 1 until 10)&#123;...&#125; //i取1到9 break与continue的使用：除了在Java中的普通用法，Kotlin还支持基于标签的用法 12345678910111213141516a@ for(i in 1..3) //标签为任意字符串+@ 如：loop@、abc@等 b@ for(j in 1..3)&#123; println(\"$i + $j\") if(i==2) continue@a //注意这里continue与@之间无空格，执行后结束本次循环，进行下一次 else if(j==2) break@b //break与@之间也不需要空格，执行后直接结束循环，执行后面的代码 &#125;/**1 + 1*1 + 2*2 + 1*3 + 1*3 + 2*/ 关于其他内容文档里面写得很仔细，我就不再赘述，这里是看文档时不太明白的地方通过编程测试后得出的结果。 - ###类与继承 类的主构造函数直接跟在类名之后 123456789/**你在Java里面这样写*class Person&#123;* Person(String firstName)&#123;&#125;*&#125;*但是在Kotlin中你可以这样写*/class Person constructor(firstName: String)&#123;&#125; //标准写法class Person(firstName: String)&#123;&#125; //当主构造函数没有可见修饰符及注解时可省略 constructor 关键字class Person(firstName: Sring) //当类没有类体可省略花括号 主构造函数不能有代码，初始化操作要放入init代码块中 123456789101112class Person(String name)&#123; val personName = name //也可以直接使用 init()&#123; println(\"name is $name\") &#125;&#125;class Person(val personName: String)&#123; //直接初始化属性 init()&#123; println(\"name is $name\") &#125;&#125; 创建类的实例不需要new关键字(Kotlin没有new关键字): 1val p = Person(\"ming\") 默认情况下，Kotlin中所有类默认均为final，只有声明了open才可以被继承 12open class Person(p : Int)class Man(p : Int):Person(p) 类方法同样如此，只有标注了open才能被覆盖，并且除了覆盖，不能有与父类相同签名的函数 1234567open class Base &#123; open fun v() &#123;&#125; fun nv() &#123;&#125;&#125;class Derived() : Base() &#123; final override fun v() &#123;&#125; //override默认方法可以被子类覆盖，可加final标注禁止子类覆盖&#125; 属性覆盖与方法相似，但var可覆盖val，反之却不行 当父类与实现的接口有函数重名时的情况文档中写得很清楚。我突然想到Java中似乎没遇到类似的情况，首先应该是这种在设计上是不合理的，一般我们在编程时特意回避了。我测试了一下在Java中当类与接口函数重名时，子类仍然只能有一个该名称函数，并且必需是重写父类的，调用时无论转型为父类还是接口均是以该函数为准。若子类不重写该方法，则接口自动调用父类该方法。 123456789101112131415161718192021222324252627282930class A&#123; public void print()&#123; System.out.println(\"A\"); &#125;&#125;interface B&#123; void print();&#125;class C extends A implements B&#123; @Override //必须加上override注解 public void print() &#123; super.print(); System.out.println(\"C\"); &#125;&#125;public static void main(String args)&#123; A a = new C(); a.print(); B b = new C(); b.print();&#125;/*输出均为：A* C*若不重写print方法，则输出均为:A*/ 但是当重名函数返回类型不同时，编辑器会报错。 abstract修饰的类和成员不用标注open Kotlin中没有静态方法。","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/tags/Kotlin/"}]},{"title":"Android Studio更新后无法debug解决","date":"2017-05-17T04:02:17.000Z","path":"2017/05/17/Android-Studio更新后无法debug解决/","text":"之前更新AS后遇到一个问题就是本来正常的项目突然在运行后无法自动调起界面了，我使用真机通过数据线连接到AS调试项目，点击运行后apk被正确安装到了手机上，但是没有在AS引导下自动打开app，并且debug也失败，无法调起debug界面。查了很多资料也没个结果，当时以为是AS新版本的问题，毕竟AS从1.5升级到2.0步子也挺大的，后来问学长却发现他没有遇到这个问题，依然跑得飞起。。。最后是一个已经工作的大神指导，让我升级Gradle版本试试，果然升级之后就OK了，这里记录一下升级过程。 直接右键点击app文件夹，打开Project Structure，或者通过File-&gt;Project Structure打开， 进入到Project栏，在这里修改Gradle和Android Plugin Version的版本，Android Plugin Version是Gradle插件版本号，这个也可以去build.gradle文件中直接修改。两者之间存在着对应关系，不能随便设置的，对应关系可以直接到官方用户指南去查看 自从AS2.0版本以后经常在更新了AS之后打开项目时提示一个更新INSTANT RUN的通知，这个我每次都没看清就点确定了，今天更新的时候才注意到更新的通知栏其实就提示了建议用户将Gradle升级3.3及插件2.3.2版本，要是更新前仔细看也就不会那么痛苦地debug好几天了吧。。。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://yoursite.com/tags/Android-Studio/"},{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"}]},{"title":"hexo+yilia主题使用微博评论箱","date":"2017-05-16T09:11:11.000Z","path":"2017/05/16/hexo-yillia主题使用微博评论箱/","text":"昨天新搭好博客之后就一直想要添加一个留言版方便和大家交流（虽然跟没有人），我使用的是litten大神的yilia主题，里面本身就帮助我们添加了畅言、多说、网易云跟帖、Disqus四种评论系统，我们只需要修改主题根目录下的_config.yml文件，配置appid就可以使用了，非常方便。 但是。。。我的环境是gitpage+hexo，并且没有自己的域名，而畅言需要域名的备案号，无法申请；网易云跟帖判断github.io url已存在，无法申请；多说将在6月关闭，不推荐使用；Disqus在墙内使用不方便，不推荐使用。。。于是我只能另谋出路。经过多方搜索，我发现友言和微博评论箱两个选择不错，于是开始添加，先说说友言的配置吧。 友言踩坑其实友言没什么好坑的，直接注册后都不用邮箱认证就能自动分配到uid，然后获取到代码直接插入到界面中就可以了（不会修改主题代码的可以参考下面微博插入代码的方法）。但是我插入之后无论是本地测试还是更新到gitpage上测试都没有出现评论框，场面异常尴尬，查了很多资料也没有个解释，于是保留了代码并且给客服反馈了，等有了解决方案再来更新。 微博评论箱接入然后讲讲微博评论箱的接入。首先是去新浪微博开放平台申请个帐号（当然直接微博登录也是可以的）。接着创建网站： 这里填入网站名称和域名可以是gitpage的地址，例如:小明的博客；djming.github.io。 验证方式我选择了第一种：在首页添加标签。首先复制上面这段代码，然后找到主页所在的页面，由于我之前没有接触过这类开发，查了很久文档才找到:我们就是要修改这个head.ejs文件，这里面包含了我们博客页面的&lt;head&gt;标签内容，hexo-theme-yilia是我的主题文件夹名，如果用的不是这个主题可以自行去找，根据hexo官方文档的规则，主题目录应该是大致相同的。在这里随便找个地方把&lt;meta&gt;标签插进去就行了，然后执行hexo d把我们的项目更新到gitpage，访问自己博客确认头信息已经被修改接着就点击验证并添加进入了漫长的等待，不知是不是微博的服务器访问gitpage特别慢，这个过程我去查询了解决友言问题的各种资料，还顺便出去给朋友送了个东西，回来看见页面还卡在这，一刷新提示网站名称已存在才明白已经创建成功了，现在进入我的应用就可以看见自己刚才申请的网站啦！ 接下来我们回到评论箱API网站可以看到这里已经和我们第一次进来不同了，需要注意的是在这个页面的第一步第二部中配置的不同会直接导致第三步复制代码框中产生的代码不同，因为评论框的样式都被写在了WBML中，第三步复制代码需要增加XML命名空间，这里依然进入我们刚才编辑的head.ejs，将&lt;html&gt;标签修改为&lt;html xmlns:wb=&quot;http://open.weibo.com/wb&quot;&gt;，并且在head中添加&lt;script src=&quot;http://tjs.sjs.sinajs.cn/open/api/js/wb.js?appkey=你的appkey&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;，最后就是将评论箱的代码复制到评论箱应该出现的地方了，在我使用yilia主题中，我直接写进了/theme/yilia/layout/_partial/article.ejs的末尾，然后执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo server查看效果。 其实可以在hexo服务运行时修改配置文件以及.md文件，再刷新页面就可以看到效果了，不需要每次clean再重启。 总结一下申请评论箱的坑： 验证过程太慢，不过是能够申请成功的，你可以喝杯咖啡。 我选择留言框的样式是不显示边框，但是实际效果还是显示了，我的解决方法是将最后需要部署WBML修改为&lt;wb:comments url=&quot;auto&quot; border=&quot;n&quot; brandline=&quot;n&quot; fontsize=&quot;12&quot; width=&quot;auto&quot; appkey=&quot;你的APPKEY&quot; &gt;&lt;/wb:comments&gt;也就是添加了border=&quot;n&quot; 身份验证和审核有点麻烦，需要身份证扫描照。 最后要说的是新浪的评论箱需要进行用户身份认证后再上线，其实也比畅言的好不了多少，不过对于没有域名也不打算买的小伙伴可以尝试一下，希望友言的问题能够尽快解决，如果你知道什么好的留言系统也请告诉我哟~ 写完以上文字后我才想起有个叫做来必力（来♂比利）的评论系统忘记了，于是去测试了一下。。。异常简单，注册完成后插入代码到页面就行了，而且有个人免费，用户可以不登录留言。。。请忘了我上面写的东西吧。。。","tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"},{"name":"评论系统","slug":"评论系统","permalink":"http://yoursite.com/tags/评论系统/"}]},{"title":"hexo+gitpage搭建过程遇到的坑","date":"2017-05-15T10:13:36.000Z","path":"2017/05/15/hexo+gitpage搭建遇到的坑/","text":"今天在看一篇某大神写得技术文章时萌生了自己搭建一个博客的想法，于是在大神博客的底部发现了使用的框架以及主题。 hexo的安装搭建很简单，官方文档很全面而且也有中文版，网上也有不少文章，这里给上链接不再赘述:官方中文文档和大神的超全面教程。 我就谈谈作为一个没接触过这类框架的小白在搭建过程中遇到的坑。 hexo如何发布到gitpage我在搭建hexo的过程中最大的疑惑就是如何把hexo搭到gitpage上？我自己是以为创建好repository后需要clone到本地进行搭建再push上服务器。其实不必这么麻烦，hexo会解决上传的问题。所以我们可以通过hexo init &lt;floder&gt;命令把项目创建在自己喜欢的目录名中。hexo d命令会根据你在_config.yml中deploy项下配置的repository的地址将项目push上去，当然前提是你已经配置好了本地了git命令。所以不用再纠结hexo init到底在哪个目录执行，怎么去上传这类的问题。 Cannot Get /在执行了hexo server没有报错情况下访问localhost:4000可能会看到这个错误页面，导致这种问题可能是两种情况： 没有执行npm install命令。 _post/目录下没有文件. 使用hexo init命令创建好项目后应该进入目录执行npm install，这个只要跟着文档中就不会有错。坑爹的是第二种情况。由于创建的项目中会有一篇默认文章来引导小白，删除这篇文章对应的.md文件后_post也就成为了空目录，这种情况同样会导致错误页面出现，所以一定要保证每个目录下都有文章撑着，特别是_post目录。 Markdown文档解析错误这个问题是在要发布的时候才发现的。。。在预览的网页中许多标题前的###等符号未被识别以及一些其他问题，这个似乎和主题也有关，并不是所以人都会遇到。解决方法就是在###与文字标题之间加一个空格而非我们普通地连写，其实这也是markdown的规范，只怪我学艺不精。 以上就是我在配置hexo时的一点心得，总体来说hexo这个框架真的很简单，各种主题也还蛮好看的，我也还在摸索当中，第一次写markdown文档排版太丑请原谅。","tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"gitpage","slug":"gitpage","permalink":"http://yoursite.com/tags/gitpage/"}]}]