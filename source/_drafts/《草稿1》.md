---
title: 《草稿1》
reward: false
date: 2017-10-26 19:24:59
tags:
  - Android
  - 设计模式
---

# 《Android源码设计模式》读书笔记一

---
## 面向对象六大原则

### 单一职责原则

同一个类中应该只有功能相同或者相似的函数。然而这个界限如何区分只有依靠程序员的经验区分。

### 开闭原则

对扩展开放，对修改封闭。程序中的一个类应该只因错误被修改，而新功能的加入应该尽量通过扩展
的方式实现。

### 里氏替换原则

所有基类出现的地方都可以使用子类完美替代。

### 依赖倒置原则

高层次的模块不依赖与低层次的模块的的实现细节目的。
划重点：
  - 高层模块不应该依赖底层模块，两者都应该依赖其抽象。
  - 抽象不应该依赖细节。
  - 细节应该依赖抽象。
在Java中，**抽象**就是**接口或抽象类**，而**细节就是实现类**。**高层模块则是调用端**。
模块间的依赖关系通过抽象发生，实现类之间不发生直接的依赖关系，依赖关系通过借口或抽象类产生。

### 接口隔离原则

客户端不应该依赖不需要的接口。

### 迪米特原则

一个对象应该对其他对象有最少的了解。

---

## 单例模式

内存中只存在一个实例对象，可避免过多的对象消耗资源。

单例模式的难点在于保证线程安全，由于内存中只存在一个对象，那么对象如何保证只被创建一次，便是一个难题，
其次如果单例模式提供写操作，那么也需要考虑在IO时的线程安全。

单例模式创建时保证线程安全的方法有一下几种：

``` java
public class Singleton{
  /*
  *俗称 饿汉模式
  *这种创建方式的优点在于对象会在类加载时被创建，属于天生的线程安全，编写简单。
  *但是如果instance本身很大，而在类加载时就被创建却一直不被使用，就会造成内存的浪费
  */
  private static instance = new Singleton();

  /*
  *个人比较喜欢以下的创建方法，由于并非原子操作因此这种写法并不绝对安全，
  *但实际上已经若非并发量巨大很难出现问题，
  *这与大部分单列模式的写法区别在于加锁之后的一步判断，避免了在加锁过程中实
  *例被初始化。而如果在第一次判断不为空就不需要再浪费时间加锁，所以锁里锁外的两次判断时必不可少的。
  *个人觉得掌握这两种方法已经足够。
  */
  private static instance;  //不直接初始化
  //private static volatile instance; 在高并发情况下如此修饰instance，虽然影响性能，但是安全性方面无懈可击。
  public static Singleton getInstance(){
    if (instance == null) {
      synchronized (Singleton.class){
        if (instance == null) {
          instance = new Singleton();
        }
      }
    }
    return instance;
  }
  /*
  *静态内部类单例模式
  *《Java并发编程实践》中推荐这种写法。
  * 静态内部类在第一次被调用时才初始化，有JVM保证线程安全。
  */
  private Singleton instance;
  public static Singleton getInstance() {
      return SingletonHolder.sInstance;
  }
  private static class SingletonHolder {
    private static final Singleton sInstance = new Singleton();
  }
}
  /*
  * 枚举类实现单列模式，写法简单，绝对地线程安全。
  * 这种写法时在今天才看到的，查了下很多地方在吹捧这种写法的好处，但由于我很少使用或看到别人
  * 使用这种写法，因此不知道对于内存的影响如何。
  */
public enum Singleton {
  INSTANCE;
  public void doSomething() {
    // do something here...
  }
}

```
#### 优点
 1. 减少内存开销
 2. 避免对资源多重占用
 3. 可以设置全局访问点

#### 缺点
 1. 难扩展
 2. 如果需要持有Context，容易引发内存泄漏

## Builder模式
将复杂的对象与它的表示分离。

#### 使用场景
1. 相同的方法，不同执行顺序导致不同的事件结果。
2. 多个部件可以装配到同一对象，但产生的结果不一样。
3. 产品类十分复杂，或不同调用顺序产生不同作用。
4. 初始化过程复杂

#### 优点
1. 封装性良好
2. 容易扩展

#### 缺点
1. 需要Builder与Director类，额外消耗内存。


## 工厂模式与抽象工厂模式
工厂模式中工厂会直接创造出特定的一种子类，比如CarFactory下就创建所有的Car，宾利、兰博基尼、布加迪威龙，
他们虽然不是同一类，但都是Car的子类。
而抽象工厂模式用于创建同一族的，比如Factory的子类可以有海尔、美的等，而他们继承的方法都是用于创造空调、冰箱。

列如Java中的Skin库（源码来自[设计模式：工厂三兄弟之抽象工厂模式](https://tracylihui.github.io/2015/07/23/designPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E4%B8%89%E5%85%84%E5%BC%9F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/)）
``` java
interface Button {  
    public void display();  
}  

//Spring按钮类：具体产品  
class SpringButton implements Button {  
    public void display() {  
        System.out.println("显示浅绿色按钮。");  
    }  
}  

//Summer按钮类：具体产品  
class SummerButton implements Button {  
    public void display() {  
        System.out.println("显示浅蓝色按钮。");  
    }
}  

//文本框接口：抽象产品  
interface TextField {  
    public void display();  
}  

//Spring文本框类：具体产品  
class SpringTextField implements TextField {  
    public void display() {  
        System.out.println("显示绿色边框文本框。");  
    }  
}  

//Summer文本框类：具体产品  
class SummerTextField implements TextField {  
    public void display() {  
        System.out.println("显示蓝色边框文本框。");  
    }
}  

//界面皮肤工厂接口：抽象工厂  
interface SkinFactory {  
    public Button createButton();  
    public TextField createTextField();  
}  

//Spring皮肤工厂：具体工厂  
class SpringSkinFactory implements SkinFactory {  
    public Button createButton() {  
        return new SpringButton();  
    }  

    public TextField createTextField() {  
        return new SpringTextField();  
    }  
}  

//Summer皮肤工厂：具体工厂  
class SummerSkinFactory implements SkinFactory {  
    public Button createButton() {  
        return new SummerButton();  
    }  

    public TextField createTextField() {  
        return new SummerTextField();  
    }  
}
```
