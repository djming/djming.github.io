---
title: 《草稿1》
reward: false
date: 2017-10-26 19:24:59
tags:
  - Android
  - 设计模式
---

# 《Android源码设计模式》读书笔记一

---
## 面向对象六大原则

### 单一职责原则

同一个类中应该只有功能相同或者相似的函数。然而这个界限如何区分只有依靠程序员的经验区分。

### 开闭原则

对扩展开放，对修改封闭。程序中的一个类应该只因错误被修改，而新功能的加入应该尽量通过扩展
的方式实现。

### 里氏替换原则

所有基类出现的地方都可以使用子类完美替代。

### 依赖倒置原则

高层次的模块不依赖与低层次的模块的的实现细节目的。
划重点：
  - 高层模块不应该依赖底层模块，两者都应该依赖其抽象。
  - 抽象不应该依赖细节。
  - 细节应该依赖抽象。
在Java中，**抽象**就是**接口或抽象类**，而**细节就是实现类**。**高层模块则是调用端**。
模块间的依赖关系通过抽象发生，实现类之间不发生直接的依赖关系，依赖关系通过借口或抽象类产生。

### 接口隔离原则

客户端不应该依赖不需要的接口。

### 迪米特原则

一个对象应该对其他对象有最少的了解。

---

## 单例模式

内存中只存在一个实例对象，可避免过多的对象消耗资源。

单例模式的难点在于保证线程安全，由于内存中只存在一个对象，那么对象如何保证只被创建一次，便是一个难题，
其次如果单例模式提供写操作，那么也需要考虑在IO时的线程安全。

单例模式创建时保证线程安全的方法有一下几种：

``` java
public class Singleton{
  /*
  *俗称 饿汉模式
  *这种创建方式的优点在于对象会在类加载时被创建，属于天生的线程安全，编写简单。
  *但是如果instance本身很大，而在类加载时就被创建却一直不被使用，就会造成内存的浪费
  */
  private static instance = new Singleton();

  /*
  *个人比较喜欢以下的创建方法，由于并非原子操作因此这种写法并不绝对安全，
  *但实际上已经若非并发量巨大很难出现问题，
  *这与大部分单列模式的写法区别在于加锁之后的一步判断，避免了在加锁过程中实
  *例被初始化。而如果在第一次判断不为空就不需要再浪费时间加锁，所以锁里锁外的两次判断时必不可少的。
  *个人觉得掌握这两种方法已经足够。
  */
  private static instance;  //不直接初始化
  //private static volatile instance; 在高并发情况下如此修饰instance，虽然影响性能，但是安全性方面无懈可击。
  public static Singleton getInstance(){
    if (instance == null) {
      synchronized (Singleton.class){
        if (instance == null) {
          instance = new Singleton();
        }
      }
    }
    return instance;
  }
  /*
  *静态内部类单例模式
  *《Java并发编程实践》中推荐这种写法。
  */
  private Singleton instance;
  public static Singleton getInstance() {
      return SingletonHolder.sInstance;
  }
  private static class SingletonHolder {
    private static final Singleton sInstance = new Singleton();
  }
}
  /*
  * 枚举类实现单列模式，写法简单，绝对地线程安全。
  * 这种写法时在今天才看到的，查了下很多地方在吹捧这种写法的好处，但由于我很少使用或看到别人
  * 使用这种写法，因此不知道对于内存的影响如何。
  */
public enum Singleton {
  INSTANCE;
  public void doSomething() {
    // do something here...
  }
}

```
