---
title: 《Java解惑》读书笔记
reward: false
date: 2017-11-24 19:42:34
tags:
---
### double、float等减不尽原因
计算机加减操作基于二进制，而二进制中有些小数无法被完全表示，就如同十进制无法完全表示1/3，
因此会出现诸如`2.00 - 1.10 = 0.89999999999`的场景。

### 整形计算
如果定义`final long f = 24 * 60 * 60 * 1000 * 1000;`IDEA很可能会提示你溢出了，然而结果实际并为超出float的值域。
产生这个问题的原因是计算式中的24、60等因素都是int类型的，因此在运行时jvm会首先将`24 * 60 * 60 * 1000 * 1000`当做int进行计算，
计算完成后再上升为**long**类型，而这时已经溢出了。解决方法很简单，将任意一个数字表示为long即可，如`final long f = 24L * 60 * 60 * 1000 * 1000;`

### 十六进制与八进制加减法
由于十六进制与八进制的数无需正负号就可以表示数字的正负，因此在进行加减法时需要注意这种特性带来的问题。
比如`0x100000000L + 0xcafebabe`由于**0xcafebabe**超出了int的值域，因此最高的符号位就被填充了，最终得到的结果是计算`0x0000000100000000 + 0xffffffffcafebabe`的结果。
要规避这类问题解决方法很简单`0x100000000L + 0xcafebabeL`
